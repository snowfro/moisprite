<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0">
    <title>Moisprite Walker</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            /* Retro stone floor using inline SVG */
            background-color: #5c5c64;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='64' height='64' viewBox='0 0 64 64'%3E%3Crect fill='%235a5a62' width='64' height='64'/%3E%3Crect fill='%23686870' x='2' y='2' width='28' height='28'/%3E%3Crect fill='%23646468' x='34' y='2' width='28' height='28'/%3E%3Crect fill='%23626268' x='2' y='34' width='28' height='28'/%3E%3Crect fill='%236a6a72' x='34' y='34' width='28' height='28'/%3E%3Crect fill='%235e5e66' x='4' y='4' width='24' height='24'/%3E%3Crect fill='%235c5c64' x='36' y='4' width='24' height='24'/%3E%3Crect fill='%235a5a62' x='4' y='36' width='24' height='24'/%3E%3Crect fill='%23606068' x='36' y='36' width='24' height='24'/%3E%3Crect fill='%234a4a52' x='0' y='0' width='64' height='2'/%3E%3Crect fill='%234a4a52' x='0' y='32' width='64' height='2'/%3E%3Crect fill='%234a4a52' x='0' y='0' width='2' height='64'/%3E%3Crect fill='%234a4a52' x='32' y='0' width='2' height='64'/%3E%3Crect fill='%23727278' x='6' y='6' width='4' height='2'/%3E%3Crect fill='%23727278' x='20' y='14' width='6' height='2'/%3E%3Crect fill='%236e6e76' x='38' y='8' width='4' height='2'/%3E%3Crect fill='%23727278' x='50' y='18' width='4' height='2'/%3E%3Crect fill='%236e6e76' x='10' y='42' width='6' height='2'/%3E%3Crect fill='%23727278' x='22' y='50' width='4' height='2'/%3E%3Crect fill='%23727278' x='42' y='40' width='4' height='2'/%3E%3Crect fill='%236e6e76' x='52' y='52' width='6' height='2'/%3E%3C/svg%3E");
            background-size: 64px 64px;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        
        .sprite {
            position: absolute;
            background-repeat: no-repeat;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        
        #sprite1 {
            background-image: url('moisprite.png');
        }
        
        #sprite2 {
            background-image: url('matsprite.png');
        }
        
        #birthday-text {
            position: absolute;
            bottom: 16%;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Press Start 2P', cursive;
            font-size: clamp(16px, 4vw, 48px);
            color: #ffd700;
            text-shadow: 
                4px 4px 0 #8b4513,
                -2px -2px 0 #ff6b00,
                2px -2px 0 #ff6b00,
                -2px 2px 0 #8b4513;
            text-align: center;
            line-height: 1.8;
            z-index: 10;
            image-rendering: pixelated;
        }
    </style>
</head>
<body>
    <div id="sprite1" class="sprite"></div>
    <div id="sprite2" class="sprite"></div>
    <div id="birthday-text"><span style="white-space: nowrap;">HAPPY BIRTHDAY</span><br>MOISES</div>
    
    <script>
        const birthdayText = document.getElementById('birthday-text');
        
        // Sprite sheet config: 4 columns, 4 rows
        const COLS = 4;
        const ROWS = 4;
        
        // Direction to row mapping
        const DIR = { UP: 0, RIGHT: 1, DOWN: 2, LEFT: 3 };
        
        // Shared state
        let spriteSize;
        let textBounds = null;
        
        // Sprite class
        class Sprite {
            constructor(elementId) {
                this.element = document.getElementById(elementId);
                this.x = 0;
                this.y = 0;
                this.targetX = 0;
                this.targetY = 0;
                this.direction = DIR.DOWN;
                this.frame = 0;
                this.speed = 2;
                this.animInterval = null;
            }
            
            resize() {
                this.element.style.width = spriteSize + 'px';
                this.element.style.height = spriteSize + 'px';
                this.element.style.backgroundSize = (spriteSize * COLS) + 'px ' + (spriteSize * ROWS) + 'px';
                this.updateFrame();
            }
            
            updateFrame() {
                const bgX = -this.frame * spriteSize;
                const bgY = -this.direction * spriteSize;
                this.element.style.backgroundPosition = bgX + 'px ' + bgY + 'px';
            }
            
            nextFrame() {
                this.frame = (this.frame + 1) % COLS;
                this.updateFrame();
            }
            
            getBounds() {
                const halfSize = spriteSize / 2;
                return {
                    left: this.x - halfSize * 0.5,
                    right: this.x + halfSize * 0.5,
                    top: this.y - halfSize * 0.3,
                    bottom: this.y + halfSize * 0.5
                };
            }
            
            checkTextCollision(nextX, nextY) {
                if (!textBounds) return false;
                
                const halfSize = spriteSize / 2;
                const bounds = {
                    left: nextX - halfSize * 0.5,
                    right: nextX + halfSize * 0.5,
                    top: nextY - halfSize * 0.3,
                    bottom: nextY + halfSize * 0.5
                };
                
                return !(bounds.right < textBounds.left ||
                         bounds.left > textBounds.right ||
                         bounds.bottom < textBounds.top ||
                         bounds.top > textBounds.bottom);
            }
            
            checkSpriteCollision(other) {
                const myBounds = this.getBounds();
                const otherBounds = other.getBounds();
                
                return !(myBounds.right < otherBounds.left ||
                         myBounds.left > otherBounds.right ||
                         myBounds.bottom < otherBounds.top ||
                         myBounds.top > otherBounds.bottom);
            }
            
            pickNewTarget() {
                this.speed = 1 + Math.random() * 3;
                const animSpeed = Math.max(80, 200 - this.speed * 30);
                clearInterval(this.animInterval);
                this.animInterval = setInterval(() => this.nextFrame(), animSpeed);
                
                // Pick a random edge to walk to
                const edge = Math.floor(Math.random() * 4);
                const margin = spriteSize * 1.5;
                
                switch(edge) {
                    case 0: // Top
                        this.targetX = Math.random() * window.innerWidth;
                        this.targetY = -margin;
                        break;
                    case 1: // Right
                        this.targetX = window.innerWidth + margin;
                        this.targetY = Math.random() * window.innerHeight;
                        break;
                    case 2: // Bottom
                        this.targetX = Math.random() * window.innerWidth;
                        this.targetY = window.innerHeight + margin;
                        break;
                    case 3: // Left
                        this.targetX = -margin;
                        this.targetY = Math.random() * window.innerHeight;
                        break;
                }
            }
            
            pickNewTargetAwayFrom(awayX, awayY) {
                this.speed = 1 + Math.random() * 3;
                const animSpeed = Math.max(80, 200 - this.speed * 30);
                clearInterval(this.animInterval);
                this.animInterval = setInterval(() => this.nextFrame(), animSpeed);
                
                // Pick a target in the opposite direction
                const safeHeight = window.innerHeight * 0.7;
                
                // Move away from the collision point
                let newTargetX, newTargetY;
                if (this.x < awayX) {
                    newTargetX = spriteSize + Math.random() * (this.x - spriteSize);
                } else {
                    newTargetX = this.x + Math.random() * (window.innerWidth - this.x - spriteSize);
                }
                if (this.y < awayY) {
                    newTargetY = spriteSize + Math.random() * Math.max(10, this.y - spriteSize);
                } else {
                    newTargetY = this.y + Math.random() * Math.max(10, safeHeight - this.y - spriteSize);
                }
                
                this.targetX = Math.max(spriteSize, Math.min(window.innerWidth - spriteSize, newTargetX));
                this.targetY = Math.max(spriteSize, Math.min(safeHeight - spriteSize, newTargetY));
            }
            
            pickEntryPoint() {
                const edge = Math.floor(Math.random() * 4);
                const margin = spriteSize * 1.5;
                
                switch(edge) {
                    case 0:
                        this.x = Math.random() * window.innerWidth;
                        this.y = -margin;
                        break;
                    case 1:
                        this.x = window.innerWidth + margin;
                        this.y = Math.random() * window.innerHeight;
                        break;
                    case 2:
                        this.x = Math.random() * window.innerWidth;
                        this.y = window.innerHeight + margin;
                        break;
                    case 3:
                        this.x = -margin;
                        this.y = Math.random() * window.innerHeight;
                        break;
                }
                
                const safeHeight = window.innerHeight * 0.7;
                this.targetX = spriteSize + Math.random() * (window.innerWidth - spriteSize * 2);
                this.targetY = spriteSize + Math.random() * (safeHeight - spriteSize * 2);
                
                this.speed = 1 + Math.random() * 3;
                const animSpeed = Math.max(80, 200 - this.speed * 30);
                this.animInterval = setInterval(() => this.nextFrame(), animSpeed);
            }
            
            updateDirection() {
                const dx = this.targetX - this.x;
                const dy = this.targetY - this.y;
                
                if (Math.abs(dx) > Math.abs(dy)) {
                    this.direction = dx > 0 ? DIR.RIGHT : DIR.LEFT;
                } else {
                    this.direction = dy > 0 ? DIR.DOWN : DIR.UP;
                }
            }
            
            updatePosition() {
                this.element.style.left = (this.x - spriteSize / 2) + 'px';
                this.element.style.top = (this.y - spriteSize / 2) + 'px';
            }
        }
        
        // Create sprites
        const sprite1 = new Sprite('sprite1');
        const sprite2 = new Sprite('sprite2');
        const sprites = [sprite1, sprite2];
        
        function updateTextBounds() {
            const rect = birthdayText.getBoundingClientRect();
            const padding = 20;
            textBounds = {
                left: rect.left - padding,
                right: rect.right + padding,
                top: rect.top - padding,
                bottom: rect.bottom + padding
            };
        }
        
        function resize() {
            spriteSize = Math.min(window.innerWidth, window.innerHeight) * 0.3;
            sprites.forEach(s => s.resize());
        }
        
        function move() {
            sprites.forEach((sprite, index) => {
                const dx = sprite.targetX - sprite.x;
                const dy = sprite.targetY - sprite.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < sprite.speed) {
                    sprite.x = sprite.targetX;
                    sprite.y = sprite.targetY;
                    
                    const margin = spriteSize * 1.5;
                    const offScreen = sprite.x < -margin || sprite.x > window.innerWidth + margin ||
                                      sprite.y < -margin || sprite.y > window.innerHeight + margin;
                    
                    if (offScreen) {
                        sprite.pickEntryPoint();
                    } else {
                        sprite.pickNewTarget();
                    }
                    sprite.updateDirection();
                } else {
                    const nextX = sprite.x + (dx / dist) * sprite.speed;
                    const nextY = sprite.y + (dy / dist) * sprite.speed;
                    
                    // Check text collision
                    if (sprite.checkTextCollision(nextX, nextY)) {
                        sprite.y -= sprite.speed * 2;
                        sprite.pickNewTargetAwayFrom(sprite.x, textBounds.top);
                        sprite.updateDirection();
                    } else {
                        sprite.x = nextX;
                        sprite.y = nextY;
                    }
                }
                
                sprite.updatePosition();
            });
            
            // Check sprite-to-sprite collision
            if (sprite1.checkSpriteCollision(sprite2)) {
                // Push them apart and pick new targets away from each other
                const dx = sprite2.x - sprite1.x;
                const dy = sprite2.y - sprite1.y;
                const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                
                // Push apart
                const pushX = (dx / dist) * sprite1.speed * 2;
                const pushY = (dy / dist) * sprite1.speed * 2;
                
                sprite1.x -= pushX;
                sprite1.y -= pushY;
                sprite2.x += pushX;
                sprite2.y += pushY;
                
                // Pick new targets away from each other
                sprite1.pickNewTargetAwayFrom(sprite2.x, sprite2.y);
                sprite2.pickNewTargetAwayFrom(sprite1.x, sprite1.y);
                sprite1.updateDirection();
                sprite2.updateDirection();
            }
            
            requestAnimationFrame(move);
        }
        
        function init() {
            resize();
            updateTextBounds();
            
            // Start sprites from different edges
            sprite1.pickEntryPoint();
            sprite1.updateDirection();
            
            // Delay second sprite slightly so they don't start together
            setTimeout(() => {
                sprite2.pickEntryPoint();
                sprite2.updateDirection();
            }, 1000);
            
            move();
        }
        
        window.addEventListener('resize', () => {
            resize();
            updateTextBounds();
        });
        window.addEventListener('load', init);
    </script>
</body>
</html>

